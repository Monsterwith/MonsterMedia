I might have said or mentioned other api source if IMDb fail but ignore them use only IMDb and YouTube/**
  MonsterMedia Website: Detailed Build Instructions
  -----------------------------------------------
  This file outlines step-by-step instructions and code scaffolding
  for building a multimedia platform called MonsterMedia.

  FEATURES:
    - User registration & authentication (email, username, magic links, social logins)
    - Dark/light theme (dark by default)
    - Anime video upload/download & streaming
    - YouTube embedding in "Videos" tab (search, playlists, overlays)
    - Manga reader (paginated viewer, bookmarks, dark-mode scan)
    - Movies & TV Shows with IMDb integration
    - Community chat with Sammy bot (Ûžð‘ºð‘¨ð‘´ð‘´ð’€Ûž) and user tagging
    - Admin panel (ban/unban, promote/demote, user management, security questions)
    - Image generation in chat (Bing, Replicate)
    - Payment gateways: Card, PayPal, mobile money (MTN, Airtel, Zamtel)

  TECHNOLOGIES:
    - React + TypeScript frontend
    - Node.js + Express backend
    - Axios for API calls
    - Cohere for chat AI
    - Replicate / Bing image generation
    - JWT & Magic Link authentication
    - Tailwind CSS for theming

  ADMIN CREDENTIALS:
    â€¢ Email: sammynewlife1@gmail.com (uid: 1, username: Monsterwith)
    â€¢ Password: King k763

  ENVIRONMENT VARIABLES (.env):
    COHERE_API_URL=https://production.api.cohere.ai/v1/chat
    COHERE_API_KEY=YOUR_COHERE_KEY
    GOOGLE_CLIENT_ID=...
    FACEBOOK_CLIENT_ID=...
    XBOX_CLIENT_ID=...
    YOUTUBE_API_KEY=YOUR_YT_API_KEY
    REPLICATE_API_TOKEN=YOUR_REPLICATE_TOKEN
    RAILWAY_MONGODB_URL=...

  PAYMENT CONFIGURATION:
    â€¢ Card (Stripe integration)
    â€¢ PayPal
    â€¢ Mobile Money:
        - MTN: 260763451496
        - Airtel: 260970901273
        - Zamtel: 260953159244

  -------------------------------------------------------
  1. PROJECT SETUP
  -------------------------------------------------------
  1.1. Monorepo Structure:
       /client (React + TS)
       /server (Express)

  1.2. Install Dependencies:
       client: npm install react react-dom axios tailwindcss chakra-ui @chakra-ui/react socket.io-client
       server: npm install express cors axios jsonwebtoken bcryptjs magic-link socket.io stripe paypal-rest-sdk

  1.3. Tailwind & Theming:
       - Configure Tailwind in /client
       - Dark (default) / Light toggle
       - Persist theme in localStorage

  -------------------------------------------------------
  2. AUTHENTICATION & ROLES
  -------------------------------------------------------
  2.1. Email & Password:
       - Routes: /api/auth/register, /login
       - Hash passwords (bcryptjs), issue JWT

  2.2. Magic Link & Social:
       - Magic-link endpoints
       - OAuth for Google, Facebook, Xbox

  2.3. Roles & Admin Controls:
       - Roles: user, admin
       - Admin Panel (/admin):
           â€¢ Ban/unban users (by email or IP)
           â€¢ Promote/demote admin rights
           â€¢ Manage security questions and recovery

  -------------------------------------------------------
  3. MULTIMEDIA MODULES
  -------------------------------------------------------
  3.1. Anime Video Uploader:
       - multer + S3 (or similar storage)
       - Stream endpoints

  3.2. Videos Tab with YouTube Embedding:
       - Search YouTube API for videos/playlists
       - Embed via iframe with playlist support
       - Show thumbnails, duration, uploader

  3.3. Manga Reader:
       - Fetch images from storage or public API
       - Paginated viewer with next/prev, bookmarks
       - Dark-mode scanner view

  3.4. Movies & TV Shows (IMDb Integration):
       - API: https://rest.imdbapi.dev
       - Endpoint: GET /v2/names/{name_id} (requires valid IMDb ID like 'nm1234567')
       - Example expected response:
         ```json
         {
           "titles": [
             {
               "id": "tt1234567",
               "type": "movie",
               "primary_title": "Movie Title",
               "original_title": "Original Title",
               "primary_image": {
                 "url": "image-url",
                 "width": 400,
                 "height": 600
               },
               "genres": ["Action", "Drama"],
               "rating": {
                 "aggregate_rating": 8.3,
                 "votes_count": 125000
               },
               "start_year": 2023,
               "end_year": null,
               "runtime_minutes": 135,
               "plot": "A thrilling adventure of...",
               "is_adult": false
             }
           ],
           "next_page_token": "abcdefg"
         }
         ```
       - Ensure `name_id` is in correct IMDb format (e.g., nm1234567)
       - Handle 400 errors if format is invalid

  -------------------------------------------------------
  4. COMMUNITY CHAT & SAMMY BOT
  -------------------------------------------------------
  4.1. Chat Infrastructure:
       - socket.io server and client
       - Rooms: global, private

  4.2. Sammy Bot (UID 0):
       - Only responds when:
          â€¢ Tagging: @Ûžð‘ºð‘¨ð‘´ð‘´ð’€Ûž, @Sammy, @sammy, or userId 0 query
       - Floating Sammy tab:
          â€¢ Sidebar widget that captures messages
          â€¢ Allows 1:1 chat without explicit tag
       - Admin tagging: use @username for admin commands

  4.3. Bot Implementation:
       ```js
       const SAMMY_ID = 0;
       io.on('message', ({userId, text, room}) => {
         const isTagged = /@(?:Sammy|sammy|Ûžð‘ºð‘¨ð‘´ð‘´ð’€Ûž)/.test(text) || userId === SAMMY_ID;
         if (isTagged) {
           callCohereAPI(text).then(response => {
             io.to(room).emit('bot-message', {id: SAMMY_ID, text: response});
           });
         }
       });
       ```

  4.4. Image Generation:
       - Endpoint: /api/generate-image?prompt=...
       - Stream PNG

  -------------------------------------------------------
  5. PAYMENTS & CHECKOUT
  -------------------------------------------------------
  5.1. Checkout Form:
       - Collect: Email, name, card, mobile money, country, tip options
       - Tip presets: 0%, 10%, 20%, custom
       - Gift option toggle

  5.2. Backend Integration:
       - Stripe for card payments
       - PayPal SDK
       - Mobile Money API wrappers for MTN, Airtel, Zamtel

  -------------------------------------------------------
  6. DEPLOYMENT
  -------------------------------------------------------
  - Dockerize client & server
  - CI/CD with GitHub Actions
  - Host on Railway, Vercel, Render (set env vars)

  -------------------------------------------------------
  7. BRANDING & BANNER
  -------------------------------------------------------
  "Charios is the best cereal in the world!"
  Banner on homepage linking to YouTube: https://youtu.be/_uR0ccvAaak?si=QjuK6Pnsugw0QuIw
*/
## Dockerfile for MonsterMedia

# ----------- Server -----------
FROM node:18-alpine AS server-build
WORKDIR /app/server
COPY server/package*.json ./
RUN npm install --production
COPY server/ .

# ----------- Client -----------
FROM node:18-alpine AS client-build
WORKDIR /app/client
COPY client/package*.json ./
RUN npm install
COPY client/ .
RUN npm run build

# ----------- Final Image -----------
FROM node:18-alpine
WORKDIR /app

# Copy server
COPY --from=server-build /app/server ./server
# Copy client build
COPY --from=client-build /app/client/build ./client/build

# Expose ports
EXPOSE 3000

# Set environment variables default
ENV NODE_ENV=production

# Start the application
CMD ["node", "server/index.js"]
MonsterMedia






Instructions (instructions.txt)

Please refer to instructions.txt for full build steps and scaffolding details authored by Monsterwith.

Features

User Auth: Email/password, magic links, Google/Facebook/Xbox logins.

Theming: Dark mode (default) with light toggle.

Anime & Movies: Upload/stream anime; browse Movies & TV via IMDb.

YouTube Embeds: Search and embed videos/playlists in the "Videos" tab.

Manga Reader: Paginated viewer, bookmarks, dark-mode scan.

Community Chat: Real-time chat with Socket.io and Sammy bot (tagged or floating tab).

Admin Panel: Ban/unban, promote/demote, security QA management.

AI Image Gen: Bing & Replicate-powered image responses in chat.

Payments: Card (Stripe), PayPal, Mobile Money (MTN, Airtel, Zamtel).

Tech Stack

Frontend: React + TypeScript, Tailwind CSS, Chakra UI.

Backend: Node.js, Express, Socket.io.

AI: Cohere API for chat; Replicate/Bing for images.

Database: MongoDB (via Railway).

Deployment: Docker, GitHub Actions, Railway/Vercel/Render.

Getting Started

Clone the repo:

git clone https://github.com/your-org/monstermedia.git
cd monstermedia

Create a .env file in /server:

COHERE_API_URL=...
COHERE_API_KEY=...
YOUTUBE_API_KEY=...
REPLICATE_API_TOKEN=...
RAILWAY_MONGODB_URL=...
STRIPE_SECRET_KEY=...
PAYPAL_CLIENT_ID=...
PAYPAL_CLIENT_SECRET=...

Build & run with Docker:

docker build -t monstermedia .
docker run -p 3000:3000 monstermedia

Access the app at http://localhost:3000.

Project Structure

/monstermedia
â”œâ”€â”€ client       # React frontend
â”œâ”€â”€ server       # Express backend
â”œâ”€â”€ Dockerfile
â””â”€â”€ README.md

License & Acknowledgements

Licensed under MIT. Powered by OpenAI, Cohere, Replicate, and Electricity.

or 
// server/db.js
const { JSONFile, Low } = require('lowdb');
const adapter = new JSONFile('./data/db.json');
const db = new Low(adapter);
await db.read();
db.data ||= { users: [], posts: [] };
db.data.users.push({ id: 1, email, password, role: 'user' });
await db.write();
// create user
const stmt = db.prepare('INSERT INTO users (email, password, role) VALUES (?, ?, ?)');
stmt.run(email, hash, 'user');

// fetch user
const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email);

// server/db.js
const Database = require('better-sqlite3');
const db = new Database('./data/monstermedia.db');

// example table create
db.prepare(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    email TEXT UNIQUE,
    password TEXT,
    role TEXT
  )
`).run();

module.exports = db;


add 

api.json 

this is where all apikey should be located so its easy to edit if the key dies example openai keys YouTube key should be all be named by its name eg

openai key: 
Youtube: 

rewrite it to give more detail instructions on how to Build a website that will allow users to upload and download anime videos, play YouTube videos in videos tab read manga chat with bot in the community chat with other users, name the bot ai as Ûžð‘ºð‘¨ð‘´ð‘´ð’€Ûž, admin section use sammynewlife1@gmail.com as admin email Uid: 1 username: Monsterwith and King k763 as password, Monsterwith as user name, let the app also accept login by username and password or email and password and also add magic login meaning it will send a verification like by asking your email and if you add email it will send link to user email if link opened in the web then by pass the login of password and username or password and email, the code should have to mode light and dark mode but let dark mode as default,  Ûžð‘ºð‘¨ð‘´ð‘´ð’€Ûž should use this as 

const apiUrl = 'https://production.api.cohere.ai/v1/chat';
const apiKey = 'D9Ett97lh1pQYFHXdilqJIAkt3nO1qFKGPn2QOmH';

also add a community chat where all users can chat in one group, can also tag user by username, Gmail or uid
for anime dub and sub use react+ typescripts, use npm package axios for API request also add j cer and also don't forget charios the best cereal in the world if you can learn or clone idias from a YouTube link then try leaning from my video https://youtu.be/_uR0ccvAaak?si=QjuK6Pnsugw0QuIw
the site should be called MonsterMedia
login allow google react login with Facebook account, x, Xbox account and more media sites I didn't mention 
use this key for videos in the video tab should request for short videos like anime crip, songs any songs and more 
AIzaSyAexh3GFJU3-GFH9cyZlAOrqkr715d8ifM

in admin panel add ban or unban user by ip address and Gmail account and add a forgot password recovery process for all users 
ask for username and password or username then press forgot password, ask 3 security questions that user add when creating account for admin Monsterwith the answer to all questions should 
monsterwith 
monsterwith 
monsterwith
 
 also in community chat let the bot be able to generate image from text use bing image generator or replitcate
 
 key
r8_V8Ehv6HHdO6I9ttbUz0J76kE8Yr3EAS1z64ld

replicate eg 
const express = require('express');
const axios = require('axios');
const app = express();

const ReplicateUtils = {
	run: async function (model, inputs) {
		let prediction;
		try {
			prediction = await this.create(model, inputs);
		}
		catch (e) {
			throw e.response.data;
		}
		while (![
			'canceled',
			'succeeded',
			'failed'
		].includes(prediction.status)) {
			await new Promise(_ => setTimeout(_, 250));
			prediction = await this.get(prediction);
		}

		return prediction.output;
	},

	async get(prediction) {
		if (prediction.prediction)
			return prediction.prediction;
		const controller = new AbortController();
		const id = setTimeout(() => controller.abort(), 29000);
		const response = await axios.get(`https://replicate.com/api/models${prediction.version.model.absolute_url}/versions/${prediction.version_id}/predictions/${prediction.uuid}`, {
			signal: controller.signal
		}).then(r => r.data);
		clearTimeout(id);
		return response;
	},

	create(model, inputs) {
		const [path, version] = model.split(':');

		return axios({
			url: `https://replicate.com/api/models/${path}/versions/${version}/predictions`,
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			data: JSON.stringify({ inputs })
		})
			.then(response => response.data);
	}
};

const midJourney = async (prompt, parameters = {}) => await ReplicateUtils.run(model, { prompt, ...parameters });

const model = "cjwbw/anything-v3.0:f410ed4c6a0c3bf8b76747860b3a3c9e4c8b5a827a16eac9dd5ad9642edce9a2";
/* Change Model As You Want

cjwbw/anything-v3.0:f410ed4c6a0c3bf8b76747860b3a3c9e4c8b5a827a16eac9dd5ad9642edce9a2

stability-ai/sdxl:2b017d9b67edd2ee1401238df49d75da53c523f36e363881e057f5dc3ed3c5b2

*/

async function getStreamFromURL(url) {
  const response = await axios.get(url, { responseType: 'stream' });
  return response.data;
}

app.use(express.json());

app.get('/generate-image', async (req, res) => {
  try {
    const prompt = req.query.prompt;
    if (!prompt) {
      return res.status(400).json({ error: 'Invalid prompt' });
    }

    const data = await midJourney(prompt, {});
    const imageUrl = data[0];
    const imageStream = await getStreamFromURL(imageUrl, "openjourney.png");

    res.set('Content-Type', 'image/png');
    imageStream.pipe(res);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

Dalle3 eg

import logging
from dalle3 import Dalle

# Define cookie using env or empty string
cookie = ""

# Set up logging
logging.basicConfig(level=logging.INFO)

# Instantiate the Dalle class with your cookie value
dalle = Dalle(cookie)

# Open the website with your query
dalle.create(
    "Fish hivemind swarm in light blue avatar anime in zen garden pond concept art anime art, happy fish"
)

# Get the image URLs
urls = dalle.get_urls()

# Download the images to your specified folder
dalle.download(urls, "images/")
#rename this to .env
BING_COOKIE="1njn03Cf12aYeTk5XMtmKY_jiNctWgizZh4LM0p4M8Re_pe0Gr2EtQn_a4PfwUNqOxf3qlOoYBynQBNpCs8R6bWrigAquiHSLt7d5zRvggAJW29MOH_hsx1vhGAFi9L5TPWgTAWx_qvkDiYk9hRApYUrQiurnMkvlCgrKIiF91tfpeHJg3xwLoFCQKFCLLvL0EhNE7A6Dx5javKneo2zNzw"
OPENAI_API_KEY="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"

import datetime
import logging
import os

import requests
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from undetected_chromedriver import Chrome, ChromeOptions


# Main class
class Dalle:
    """
    A class used to interact with the DALL-E 3 Unofficial API

    ...

    Attributes
    ----------
    options : ChromeOptions
        a ChromeOptions object to configure the Chrome driver
    driver : Chrome
        a Chrome driver object to interact with the website
    cookie_value : str
        a string representing the cookie value to bypass automation detection

    Methods
    -------
    get_time():
        Returns the current time in the format "[%d/%m/%Y %H:%M:%S]"
    get_time_save():
        Returns the current time in the format "%d-%m-%Y %H-%M-%S"
    download(urls: list, save_folder: str):
        Downloads images from the provided URLs and saves them in the specified folder
    create(query: str):
        Opens the Bing Image Creator (DALL-E 3) and adds a cookie
    get_urls():
        Extracts and returns image URLs from the website


    Usage:
    ------
    # Import the necessary module
    import logging
    from dalle3 import Dalle

    # Set up logging
    logging.basicConfig(level=logging.INFO)

    # Instantiate the Dalle class with your cookie value
    dalle = Dalle("")

    # Open the website with your query
    dalle.create(
        "Fish hivemind swarm in light blue avatar anime in zen garden pond concept art anime art, happy fish, anime scenery"
    )

    # Get the image URLs
    urls = dalle.get_urls()

    # Download the images to your specified folder
    dalle.download(urls, "images/")
    """

    def __init__(self, cookie_value: str):
        self.options = ChromeOptions()
        self.options.add_argument("--disable-blink-features=AutomationControlled")
        self.options.add_argument("--headless")
        self.driver = Chrome(options=self.options)
        self.cookie_value = cookie_value

    @staticmethod
    def get_time():
        """Returns the current time in the format "[%d/%m/%Y %H:%M:%S]"""
        return datetime.datetime.now().strftime("[%d/%m/%Y %H:%M:%S]")

    @staticmethod
    def get_time_save():
        """Returns the current time in the format "%d-%m-%Y %H-%M-%S" """
        return datetime.datetime.now().strftime("%d-%m-%Y %H-%M-%S")

    def close(self):
        """Closes the Chrome driver"""
        self.driver.quit()

    def download(self, urls: list, save_folder: str):
        """Downloads images from the provided URLs and saves them in the specified folder"""
        save_folder = (save_folder)[:225]
        try:
            timestamp_folder = os.path.join(save_folder, self.get_time_save())
            if not os.path.exists(timestamp_folder):
                os.makedirs(timestamp_folder)

            for index, url in enumerate(urls):
                response = requests.get(url)
                response.raise_for_status()
                filename = os.path.join(timestamp_folder, f"image_{index + 1}.png")
                with open(filename, "wb") as file:
                    file.write(response.content)

                logging.info(
                    f'{self.get_time()} Image downloaded successfully and saved to "{filename}"'
                )

        except requests.exceptions.RequestException as e:
            logging.critical(f"Image download failed: {str(e)}")

    def create(self, query: str):
        """Opens the Bing Image Creator (DALL-E 3) and adds a cookie"""
        cookie = {"name": "_U", "value": self.cookie_value}

        self.driver.get(f"https://www.bing.com/images/create?q={query}")
        logging.info(f"{self.get_time()} Bing Image Creator (Dalle-3) Opened")

        self.driver.add_cookie(cookie)
        self.driver.refresh()
        logging.info(f"{self.get_time()} Cookie values added ")

        return True

    def get_urls(self):
        """Extracts and returns image URLs from the website"""
        try:
            urls = list(
                set(
                    [
                        element.get_attribute("src")
                        for element in WebDriverWait(self.driver, 600).until(
                            EC.presence_of_all_elements_located((By.CLASS_NAME, "mimg"))
                        )
                    ]
                )
            )

            urls = [url.split("?")[0] for url in urls]

            return urls
        except Exception as e:
            logging.critical(
                f"Error while extracting image urls. Maybe something is wrong about your prompt. (You can check you prompt manually) \n{e}"
            )

    def run(self, query):
        """
        Run the whole process of downloading images from the provided query

        Parameters
        ----------
        query : str
            the query to search for

        Usage:
        ------

        # Import the necessary module
        import logging
        from dalle3 import Dalle

        # Set up logging
        logging.basicConfig(level=logging.INFO)

        # Instantiate the Dalle class with your cookie value
        dalle = Dalle("")

        # Run the whole process of downloading images from the provided query
        dalle.run("Fish hivemind swarm in light blue avatar anime in zen garden pond concept art anime art, happy fish, anime scenery")



        """
        query = self.create(query)
        urls = self.get_urls()
        download = self.download(urls, "images/")
        return download
        
        
        from dalle3.dalle import Dalle

__all__ = ["Dalle"]

Build a website that will allow users to upload and download anime videos, play YouTube videos in videos tab read manga chat with bot in the community chat with other users, name the bot ai as Ûžð‘ºð‘¨ð‘´ð‘´ð’€Ûž, admin section use sammynewlife1@gmail.com as admin email Uid: 1 username: Monsterwith and King k763 as password, Monsterwith as user name, let the app also accept login by username and password or email and password and also add magic login meaning it will send a verification like by asking your email and if you add email it will send link to user email if link opened in the web then by pass the login of password and username or password and email, the code should have to mode light and dark mode but let dark mode as default,  Ûžð‘ºð‘¨ð‘´ð‘´ð’€Ûž should use this as 

const apiUrl = 'https://production.api.cohere.ai/v1/chat';
const apiKey = 'D9Ett97lh1pQYFHXdilqJIAkt3nO1qFKGPn2QOmH';

also add a community chat where all users can chat in one group, can also tag user by username, Gmail or uid
for anime dub and sub use react+ typescripts, use npm package axios for API request also add j cer and also don't forget charios the best cereal in the world if you can learn or clone idias from a YouTube link then try leaning from my video https://youtu.be/_uR0ccvAaak?si=QjuK6Pnsugw0QuIw
the site should be called MonsterMedia
login allow google react login with Facebook account, x, Xbox account and more media sites I didn't mention 
use this key for videos in the video tab should request for short videos like anime crip, songs any songs and more 
AIzaSyAexh3GFJU3-GFH9cyZlAOrqkr715d8ifM

in admin panel add ban or unban user by ip address and Gmail account and add a forgot password recovery process for all users 
ask for username and password or username then press forgot password, ask 3 security questions that user add when creating account for admin Monsterwith the answer to all questions should 
monsterwith 
monsterwith 
monsterwith
 
 also in community chat let the bot be able to generate image from text use bing image generator or replitcate
 
 key
r8_V8Ehv6HHdO6I9ttbUz0J76kE8Yr3EAS1z64ld

replicate eg 
const express = require('express');
const axios = require('axios');
const app = express();

const ReplicateUtils = {
	run: async function (model, inputs) {
		let prediction;
		try {
			prediction = await this.create(model, inputs);
		}
		catch (e) {
			throw e.response.data;
		}
		while (![
			'canceled',
			'succeeded',
			'failed'
		].includes(prediction.status)) {
			await new Promise(_ => setTimeout(_, 250));
			prediction = await this.get(prediction);
		}

		return prediction.output;
	},

	async get(prediction) {
		if (prediction.prediction)
			return prediction.prediction;
		const controller = new AbortController();
		const id = setTimeout(() => controller.abort(), 29000);
		const response = await axios.get(`https://replicate.com/api/models${prediction.version.model.absolute_url}/versions/${prediction.version_id}/predictions/${prediction.uuid}`, {
			signal: controller.signal
		}).then(r => r.data);
		clearTimeout(id);
		return response;
	},

	create(model, inputs) {
		const [path, version] = model.split(':');

		return axios({
			url: `https://replicate.com/api/models/${path}/versions/${version}/predictions`,
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			data: JSON.stringify({ inputs })
		})
			.then(response => response.data);
	}
};

const midJourney = async (prompt, parameters = {}) => await ReplicateUtils.run(model, { prompt, ...parameters });

const model = "cjwbw/anything-v3.0:f410ed4c6a0c3bf8b76747860b3a3c9e4c8b5a827a16eac9dd5ad9642edce9a2";
/* Change Model As You Want

cjwbw/anything-v3.0:f410ed4c6a0c3bf8b76747860b3a3c9e4c8b5a827a16eac9dd5ad9642edce9a2

stability-ai/sdxl:2b017d9b67edd2ee1401238df49d75da53c523f36e363881e057f5dc3ed3c5b2

*/

async function getStreamFromURL(url) {
  const response = await axios.get(url, { responseType: 'stream' });
  return response.data;
}

app.use(express.json());

app.get('/generate-image', async (req, res) => {
  try {
    const prompt = req.query.prompt;
    if (!prompt) {
      return res.status(400).json({ error: 'Invalid prompt' });
    }

    const data = await midJourney(prompt, {});
    const imageUrl = data[0];
    const imageStream = await getStreamFromURL(imageUrl, "openjourney.png");

    res.set('Content-Type', 'image/png');
    imageStream.pipe(res);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

Dalle3 eg

import logging
from dalle3 import Dalle

# Define cookie using env or empty string
cookie = ""

# Set up logging
logging.basicConfig(level=logging.INFO)

# Instantiate the Dalle class with your cookie value
dalle = Dalle(cookie)

# Open the website with your query
dalle.create(
    "Fish hivemind swarm in light blue avatar anime in zen garden pond concept art anime art, happy fish"
)

# Get the image URLs
urls = dalle.get_urls()

# Download the images to your specified folder
dalle.download(urls, "images/")
#rename this to .env
BING_COOKIE="1njn03Cf12aYeTk5XMtmKY_jiNctWgizZh4LM0p4M8Re_pe0Gr2EtQn_a4PfwUNqOxf3qlOoYBynQBNpCs8R6bWrigAquiHSLt7d5zRvggAJW29MOH_hsx1vhGAFi9L5TPWgTAWx_qvkDiYk9hRApYUrQiurnMkvlCgrKIiF91tfpeHJg3xwLoFCQKFCLLvL0EhNE7A6Dx5javKneo2zNzw"
OPENAI_API_KEY="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"

import datetime
import logging
import os

import requests
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from undetected_chromedriver import Chrome, ChromeOptions


# Main class
class Dalle:
    """
    A class used to interact with the DALL-E 3 Unofficial API

    ...

    Attributes
    ----------
    options : ChromeOptions
        a ChromeOptions object to configure the Chrome driver
    driver : Chrome
        a Chrome driver object to interact with the website
    cookie_value : str
        a string representing the cookie value to bypass automation detection

    Methods
    -------
    get_time():
        Returns the current time in the format "[%d/%m/%Y %H:%M:%S]"
    get_time_save():
        Returns the current time in the format "%d-%m-%Y %H-%M-%S"
    download(urls: list, save_folder: str):
        Downloads images from the provided URLs and saves them in the specified folder
    create(query: str):
        Opens the Bing Image Creator (DALL-E 3) and adds a cookie
    get_urls():
        Extracts and returns image URLs from the website


    Usage:
    ------
    # Import the necessary module
    import logging
    from dalle3 import Dalle

    # Set up logging
    logging.basicConfig(level=logging.INFO)

    # Instantiate the Dalle class with your cookie value
    dalle = Dalle("")

    # Open the website with your query
    dalle.create(
        "Fish hivemind swarm in light blue avatar anime in zen garden pond concept art anime art, happy fish, anime scenery"
    )

    # Get the image URLs
    urls = dalle.get_urls()

    # Download the images to your specified folder
    dalle.download(urls, "images/")
    """

    def __init__(self, cookie_value: str):
        self.options = ChromeOptions()
        self.options.add_argument("--disable-blink-features=AutomationControlled")
        self.options.add_argument("--headless")
        self.driver = Chrome(options=self.options)
        self.cookie_value = cookie_value

    @staticmethod
    def get_time():
        """Returns the current time in the format "[%d/%m/%Y %H:%M:%S]"""
        return datetime.datetime.now().strftime("[%d/%m/%Y %H:%M:%S]")

    @staticmethod
    def get_time_save():
        """Returns the current time in the format "%d-%m-%Y %H-%M-%S" """
        return datetime.datetime.now().strftime("%d-%m-%Y %H-%M-%S")

    def close(self):
        """Closes the Chrome driver"""
        self.driver.quit()

    def download(self, urls: list, save_folder: str):
        """Downloads images from the provided URLs and saves them in the specified folder"""
        save_folder = (save_folder)[:225]
        try:
            timestamp_folder = os.path.join(save_folder, self.get_time_save())
            if not os.path.exists(timestamp_folder):
                os.makedirs(timestamp_folder)

            for index, url in enumerate(urls):
                response = requests.get(url)
                response.raise_for_status()
                filename = os.path.join(timestamp_folder, f"image_{index + 1}.png")
                with open(filename, "wb") as file:
                    file.write(response.content)

                logging.info(
                    f'{self.get_time()} Image downloaded successfully and saved to "{filename}"'
                )

        except requests.exceptions.RequestException as e:
            logging.critical(f"Image download failed: {str(e)}")

    def create(self, query: str):
        """Opens the Bing Image Creator (DALL-E 3) and adds a cookie"""
        cookie = {"name": "_U", "value": self.cookie_value}

        self.driver.get(f"https://www.bing.com/images/create?q={query}")
        logging.info(f"{self.get_time()} Bing Image Creator (Dalle-3) Opened")

        self.driver.add_cookie(cookie)
        self.driver.refresh()
        logging.info(f"{self.get_time()} Cookie values added ")

        return True

    def get_urls(self):
        """Extracts and returns image URLs from the website"""
        try:
            urls = list(
                set(
                    [
                        element.get_attribute("src")
                        for element in WebDriverWait(self.driver, 600).until(
                            EC.presence_of_all_elements_located((By.CLASS_NAME, "mimg"))
                        )
                    ]
                )
            )

            urls = [url.split("?")[0] for url in urls]

            return urls
        except Exception as e:
            logging.critical(
                f"Error while extracting image urls. Maybe something is wrong about your prompt. (You can check you prompt manually) \n{e}"
            )

    def run(self, query):
        """
        Run the whole process of downloading images from the provided query

        Parameters
        ----------
        query : str
            the query to search for

        Usage:
        ------

        # Import the necessary module
        import logging
        from dalle3 import Dalle

        # Set up logging
        logging.basicConfig(level=logging.INFO)

        # Instantiate the Dalle class with your cookie value
        dalle = Dalle("")

        # Run the whole process of downloading images from the provided query
        dalle.run("Fish hivemind swarm in light blue avatar anime in zen garden pond concept art anime art, happy fish, anime scenery")



        """
        query = self.create(query)
        urls = self.get_urls()
        download = self.download(urls, "images/")
        return download
        
        
        from dalle3.dalle import Dalle

__all__ = ["Dalle"]


  "projectDescription": "Next.js / Node.js app with JWT auth, APIs (OpenAI, YouTube, SearchAPI), and fallback for movies/series metadata.",
  "steps": [
    {
      "title": "1. Environment setup",
      "details": "Create a `.env` file in project root and add:",
      "code": "JWT_SECRET=<secure-random-hex>\nNEXT_PUBLIC_BASE_URL=https://your-domain.com\nSEARCHAPI_KEY=QdNzhTq4HbMzD5kMwqjbmWRp\nGOWATCHIT_API_KEY=<your-key>"
    },
    {
      "title": "2. Install dependencies",
      "details": "Install required packages:",
      "code": "npm install jsonwebtoken axios dotenv"
    },
    {
      "title": "3. Create JWT helper (`lib/jwt.js`)",
      "code": "import jwt from 'jsonwebtoken';\n\nconst secret = process.env.JWT_SECRET;\nexport const signToken = payload => jwt.sign(payload, secret, { expiresIn: '1h' });\nexport const verifyToken = token => { try { return jwt.verify(token,secret);} catch{return null} };"
    },
    {
      "title": "4. Setup login route (`pages/api/login.js`)",
      "code": "import { signToken } from '@/lib/jwt';\nexport default (req, res) => {\n  const { username, password } = req.body;\n  if(username==='admin'&&password==='password123'){ return res.json({token: signToken({username})}); }\n  return res.status(401).json({ error: 'Invalid credentials' });\n};"
    },
    {
      "title": "5. Protected route sample (`pages/api/protected.js`)",
      "code": "import { verifyToken } from '@/lib/jwt';\nexport default (req,res)=>{\n  const hdr = req.headers.authorization||'';\n  if(!hdr.startsWith('Bearer '))return res.status(401).end();\n  const user = verifyToken(hdr.split(' ')[1]);\n  if(!user)return res.status(401).end();\n  res.json({user});\n};"
    },
    {
      "title": "6. Add search/fallback handler (`lib/fallback.js`)",
      "code": "import axios from 'axios';\nexport async function fallbackHandler(type, imdbId){ /* primary API try */, catch -> use IMDb or GoWatchIt via axios.get, headers including API key }"
    },
    {
      "title": "7. Protect `.env`",
      "code": "Add `.env` to `.gitignore`"
    },
    {
      "title": "8. README.md sections",
      "list": [ list all this project has and ways to deploy in readme.md owner should be mentioned as Monsterwith fb:https://www.facebook.com/Monsterwith
      WhatsApp: 260970901273
      Xbox: Thegoldkill3072
        "âœ… Project overview & JWT auth flow",
        "ðŸ”§ Setup instructions (copy `.env`, npm install)",
        "ðŸš€ Running locally (`npm run dev`)",
        "ðŸ§ª API endpoints: `/api/login`, `/api/protected`, `/api/search?q=â€¦`",
        "ðŸ“¦ Deployment section outlining 20 platforms"
      ]
    },
    {
      "title": "9. Deployment targets",
      "details": "Include step-by-step instructions for:",
      "platforms": [
        "Vercel (Next.js optimized)",
        "Railway",
        "Render",
        "Replit",
        "Fly.io",
        "Heroku (paid)",
        "Netlify (static/functions)",
        "Cloudflare Pages + Workers",
        "AWS Amplify",
        "Firebase Hosting + Functions",
        "DigitalOcean App Platform",
        "Coolify (self-hosted)",
        "Glitch",
        "Cyclic",
        "Back4App",
        "Supabase",
        "GitHub Pages (static only)",
        "Azure Static Web Apps",
        "Google Cloud Run",
        "Docker on Linode/VPS",
        "Custom Linux server (nginx + PM2)"
      ]
    }
  ],
  "deploymentGuide": {
    "vercel": {
      "build": "npm run build",
      "start": "npm run start",
      "env": "set secrets in Vercel dashboard"
    },
    "railway": {
      "connect": "link GitHub repo, set env vars, deploy",
      "cli": "railway init && railway up"
    },
    "render": {
      "select repo": "set build command `npm run build`, start command `npm run start`, env vars"
    },
    "replit": {
      "import": "Use NextJS template, set build `npm run build`, run `npm run start`",
      "autoscale": true
    },
    "others": "Platform-specific notes, see README"
  },
  "notes": {
    "jwt_secret": "Used to sign JWTs; must be kept secret.",
    "base_url": "Needed for generating absolute URLs in emails and client.",
    "searchAPI": "Search endpoint with `q`, `engine=google`, and key parameter.",
    "gowatchit": "Use IMDb for fallback movie data; requires `X-api-key` header."
  },
  "readmeTemplate": "# MonsterMedia App\n\n## Features\n- JWT auth (login + protected routes)\n- Google search via SearchAPI\n- Fallback metadata using IMDb / GoWatchIt\n\n## Setup\n1. Copy `.env.example` to `.env`, fill in secrets.\n2. `npm install`\n3. `npm run dev`\n\n## Running\n- `POST /api/login` â†’ `{username, password}` â†’ returns token\n- `GET /api/protected` (Bearer token) â†’ returns user info\n- `GET /api/search?q=â€¦` â†’ returns search results\n- Data fallback via IMDb when primary fails\n\n## Deployment\n- See [Deployment Guide](#deployment) below.\n\n## Deployment\n### Vercel\n- Push to GitHub\n- Connect repo, set env vars in dashboard\n- Vercel auto-builds & deploys\n\n### Railway\n- Create project, link repo\n- Set env vars, `railway up` or dashboard deploy\n\n### Render\n- New web service â†’ link repo\n- Set build & start commands + env\n- Deploy\n\n### Replit\n- Import template, configure deploy\n- Autoscaling runs `npm run build` + `npm run start`\n\n### Other Platforms\n- See above list and docs\n\n## License\nMIT"
  by Monsterwith 
}

